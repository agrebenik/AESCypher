//
// Created by usagi on 5/15/2024.
//

#include "Util.h"

void KeyExpansion(const unsigned char* rgcKey, unsigned int* rgu32Expanded) {

    // the first 128 bits of the key expansion are the original key
    for (int n = 0; n < 16; ++n) {
        rgu32Expanded[n] = rgcKey[n];
    }

    int nGenerated = 16; // we have generated 16 of the 176 bytes
    int nRound = 1;      // keep track of the current round
    unsigned int rgu32Core[4];

    while (nGenerated < 176) {

        // read the four previously generated bytes into core
        for (int n = 0; n < 4; ++n) {
            rgu32Core[n] = rgu32Expanded[n + nGenerated - 4];
        }

        // for every 16 bytes perform one iteration of applying s-box and round constant
        if (nGenerated % 16 == 0) {

            // rotate core one to the left
            unsigned int u32Temp = rgu32Core[0];
            rgu32Core[0] = rgu32Core[1];
            rgu32Core[1] = rgu32Core[2];
            rgu32Core[2] = rgu32Core[3];
            rgu32Core[3] = u32Temp;

            // apply forward s-box to each row
            rgu32Core[0] = rgu32ForwardSBox[rgu32Core[0]];
            rgu32Core[1] = rgu32ForwardSBox[rgu32Core[1]];
            rgu32Core[2] = rgu32ForwardSBox[rgu32Core[2]];
            rgu32Core[3] = rgu32ForwardSBox[rgu32Core[3]];

            // xor with round constant
            rgu32Core[0] ^= rgu32RoundConstants[nRound];

            // we progress onto the next round constant
            nRound++;
        }

        // xor value from one round ago with core to get 4 bytes of expanded key
        for (int n = 0; n < 4; ++n) {
            rgu32Expanded[nGenerated] = rgu32Expanded[nGenerated - 16] ^ rgu32Core[n];
            nGenerated++;
        }
    }
}